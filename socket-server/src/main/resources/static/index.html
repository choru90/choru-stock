<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Live Stock Ticks</title>
    <style>/* 생략: 기존 스타일 그대로 */</style>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
</head>
<body>
<h1>Live Stock Ticks</h1>
<div style="padding:0 20px;">
    <label for="symbolSelect">Symbol:</label>
    <select id="symbolSelect"></select>
</div>
<div style="padding:0 20px;">
    <canvas id="chart" width="800" height="400" style="background:#fff;border:1px solid #ccc;"></canvas>
</div>
<table id="tick-table">
    <thead>
    <tr>
        <th>Symbol</th>
        <th>Price</th>
        <th>Timestamp</th>
        <th>Volume</th>
    </tr>
    </thead>
    <tbody></tbody>
</table>

<script>
    const tbody = document.querySelector('#tick-table tbody');
    const symbolSelect = document.getElementById('symbolSelect');
    const availableSymbols = ['AAPL', 'GOOG', 'TSLA', 'AMZN'];

    // 드롭다운에 종목 옵션 추가
    availableSymbols.forEach(symbol => {
        const option = document.createElement('option');
        option.value = symbol;
        option.textContent = symbol;
        symbolSelect.appendChild(option);
    });

    // STOMP 클라이언트 초기화
    const socket = new SockJS('/ws');
    const stompClient = Stomp.over(socket);
    let currentSubscription = null;

    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');
    const candles = [];
    const candleDuration = 60 * 1000; // 1분
    const maxCandles = 50;

    function subscribeTo(symbol) {
        if (currentSubscription) {
            currentSubscription.unsubscribe();
        }
        tbody.innerHTML = '';
        candles.length = 0;
        drawChart();
        currentSubscription = stompClient.subscribe(`/topic/ticks/${symbol}`, message => {
            const tick = JSON.parse(message.body);
            addRow(tick);
            addTickToCandles(tick);
        });
    }

    // 서버에 연결된 후 선택된 종목을 구독한다
    stompClient.connect({}, () => {
        subscribeTo(symbolSelect.value);
    });

    // 선택 변경 시 새 종목을 구독한다
    symbolSelect.addEventListener('change', () => {
        if (stompClient.connected) {
            subscribeTo(symbolSelect.value);
        }
    });

    function addRow(tick) {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${tick.symbol}</td>
            <td>${tick.price}</td>
            <td>${new Date(tick.timestamp).toLocaleString()}</td>
            <td>${tick.volume}</td>`;
        tbody.prepend(row);
        if (tbody.rows.length > 50) {
            tbody.removeChild(tbody.lastChild);
        }
    }

    function addTickToCandles(tick) {
        const bucket = Math.floor(tick.timestamp / candleDuration) * candleDuration;
        let candle = candles[candles.length - 1];
        if (!candle || candle.timestamp !== bucket) {
            candle = { timestamp: bucket, open: tick.price, high: tick.price, low: tick.price, close: tick.price };
            candles.push(candle);
            if (candles.length > maxCandles) candles.shift();
        } else {
            candle.high = Math.max(candle.high, tick.price);
            candle.low = Math.min(candle.low, tick.price);
            candle.close = tick.price;
        }
        drawChart();
    }

    function drawChart() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (candles.length === 0) return;
        const prices = candles.flatMap(c => [c.high, c.low]);
        const min = Math.min(...prices);
        const max = Math.max(...prices);
        const pad = 10;
        const scale = (canvas.height - pad * 2) / (max - min || 1);
        const width = canvas.width / candles.length;
        candles.forEach((c, i) => {
            const x = i * width + width / 2;
            const yHigh = canvas.height - (c.high - min) * scale - pad;
            const yLow = canvas.height - (c.low - min) * scale - pad;
            ctx.beginPath();
            ctx.moveTo(x, yHigh);
            ctx.lineTo(x, yLow);
            ctx.strokeStyle = '#000';
            ctx.stroke();
            const yOpen = canvas.height - (c.open - min) * scale - pad;
            const yClose = canvas.height - (c.close - min) * scale - pad;
            ctx.fillStyle = c.close >= c.open ? '#0f0' : '#f00';
            const rectY = Math.min(yOpen, yClose);
            const rectH = Math.max(Math.abs(yClose - yOpen), 1);
            ctx.fillRect(x - width * 0.4, rectY, width * 0.8, rectH);
        });
    }
</script>
</body>
</html>